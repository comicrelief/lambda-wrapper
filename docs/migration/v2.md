# Migrating from v1 to v2

This doc summarises the breaking changes introduced in v2 and what you need to do to update your projects to work with it.

- [Configuration](#configuration)
- [Wrapping a function](#wrapping-a-function)
- [Dependency injection](#dependency-injection)
- [Models](#models)
  - [StatusModel](#statusmodel)

The new version of dependency injection does not work if code is minified. See [Notes](../../README.md#notes) in the main readme for how to turn this off in webpack.

## Configuration

v1 required several consts with shouty names. In v2 these are replaced with a single config object with camel-case keys. You pass this to the new `configure` method to get a configured instance of `LambdaWrapper`.

Instead of this:

```js
// src/config/Configuration.js
import { DEFINITIONS as CORE_DEFINITIONS } from '@comicrelief/lambda-wrapper';

import { MyService } from '@/src/services/MyService';

export const DEFINITIONS = {
  ...CORE_DEFINITIONS,
  MY_SERVICE: 'MY_SERVICE',
};

export const DEPENDENCIES = {
  [DEFINITIONS.MY_SERVICE]: MyService,
};

export const QUEUE_DEFINITIONS = {
  MY_QUEUE: 'MY_QUEUE',
};

export const QUEUES = {
  [QUEUE_DEFINITIONS.MY_QUEUE]: process.env.SQS_MY_QUEUE,
};

export default {
  DEFINITIONS,
  DEPENDENCIES,
  QUEUE_DEFINITIONS,
  QUEUES,
};
```

do this:

```ts
// src/config/LambdaWrapper.ts
import lw from '@comicrelief/lambda-wrapper';

import { MyService } from '@/src/services/MyService';

export const lambdaWrapper = lw.configure({
  dependencies: {
    MyService,
  },
  sqs: {
    queues: {
      myQueue: process.env.SQS_MY_QUEUE as string,
    },
  },
});
```

## Wrapping a function

Rather than passing in a config object everywhere you use Lambda Wrapper, you now simply use the configured instance.

v2 also drops support for callback-style async. Use promises instead.

Finally, there is no longer a `request` parameter provided to your wrapped function. You can get this from `di` if you need it.

Instead of this:

```js
import { LambdaWrapper } from '@comicrelief/lambda-wrapper';

import { CONFIGURATION, DEFINITIONS } from '@/src/config/Configuration';

export default LambdaWrapper(CONFIGURATION, (di, request, done) => {
  // ...
  done(null, response);
});
```

do this:

```ts
import lambdaWrapper from '@/src/config/LambdaWrapper';

export default lambdaWrapper.wrap(async (di) => {
  const request = di.get(RequestService);
  // ...
  return response;
});
```

If your project doesn't add any additional services to dependency injection, you can also now use `lambdaWrapper` straight out of the box:

```ts
import lambdaWrapper from '@comicrelief/lambda-wrapper';

export default lambdaWrapper.wrap(async (di) => {
  // ...
});
```

## Dependency injection

As you'll have seen in the above examples, dependencies are no longer identified by a `DEFINITIONS` string. The `get` method now takes the dependency class directly.

Instead of this:

```js
import { LambdaWrapper } from '@comicrelief/lambda-wrapper';

import { CONFIGURATION, DEFINITIONS } from '@/src/config/Configuration';

export default LambdaWrapper(CONFIGURATION, (di, request, done) => {
  const logger = di.get(DEFINITIONS.LOGGER);
  const myService = di.get(DEFINITIONS.MY_SERVICE);
  // ...
});
```

do this:

```ts
import { LoggerService, RequestService } from '@comicrelief/lambda-wrapper';

import lambdaWrapper from '@/src/config/LambdaWrapper';
import { MyService } from '@/src/services/MyService';

export default lambdaWrapper.wrap(async (di) => {
  const logger = di.get(LoggerService);
  const request = di.get(RequestService);
  const myService = di.get(MyService);
  // ...
});
```

`get` will also always throw an error when used in a constructor to avoid surprises where other dependencies may be `undefined`. Instead of storing references to dependencies in class members, `get` them just before use.

The `definitions` property has been removed.

The `getEvent`, `getContext` and `getConfiguration` methods have been deprecated and will be removed in a future major release. Use the `event`, `context` and `config` properties directly.

## Models

The `Model` base class has been removed. It's hard to make it type-safe (it tries to dynamically call setter methods) and we do modelling and validation differently now, using our [data-models](https://github.com/comicrelief/data-models) repo which is based around [Yup](https://github.com/jquense/yup).

The `MarketingPreference` model is removed, as this is application-specific and again is replaced by our [data-models](https://github.com/comicrelief/data-models) repo.

The `StatusModel` model has been replaced by a simple object type. See the [StatusModel](#statusmodel) section below.

Other models (`ResponseModel`, `SQSMessageModel`) are unaffected except that they no longer inherit from a common `Model` class.

### `StatusModel`

Service statuses are now simple objects with the `ServiceStatus` type. The `STATUS_TYPES` object has also been removed in favour of a string union type.

Instead of this:

```js
import { StatusModel, STATUS_TYPES } from '@comicrelief/lambda-wrapper';

async function checkStatus() {
  const result = new StatusModel('My service', STATUS_TYPES.OK);
  try {
    await testMyService(); // some function that throws if there's a failure
  } catch (error) {
    result.setStatus(STATUS_TYPES.APPLICATION_FAILURE);
  }
  return result;
}
```

do this:

```ts
import { ServiceStatus, StatusValue } from '@comicrelief/lambda-wrapper';

async function checkStatus(): Promise<ServiceStatus> {
  let status: StatusValue;
  try {
    await testMyService(); // some function that throws if there's a failure
    status = 'OK';
  } catch (error) {
    status = 'APPLICATION_FAILURE';
  }
  return {
    service: 'My service',
    status,
  };
}
```

Note that we can keep `status` unset initially, and TypeScript will complain if you forget to set it before `checkStatus` returns.
