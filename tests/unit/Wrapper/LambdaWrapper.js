import ServerlessMochaPlugin from 'serverless-mocha-plugin';
import sinon from 'sinon';

import { DEFINITIONS } from '../../../src/Config/Dependencies';
import RequestService, { REQUEST_TYPES } from '../../../src/Service/Request.service';
import DependencyInjection from '../../../src/DependencyInjection/DependencyInjection.class';
import LambdaWrapper from '../../../src/Wrapper/LambdaWrapper';
import LambdaTermination from '../../../src/Wrapper/LambdaTermination';

const { expect } = ServerlessMochaPlugin.chai;

const getEvent = require('../../mocks/aws/event.json');
const getContext = require('../../mocks/aws/context.json');

describe('Wrapper/LambdaWrapper', () => {
  let dependencyInjection = {};
  let requestService = {};

  const configuration = {
    DEFINITIONS: {},
    DEPENDENCIES: {},
  };

  describe('should inject dependency injection into the function', () => {
    LambdaWrapper(configuration, (di, request) => {
      dependencyInjection = di;
      requestService = request;
    })(getEvent, getContext);

    it('dependency injection variables should be an instance of the dependency injection class', () => {
      expect(dependencyInjection instanceof DependencyInjection).to.be.true;
    });

    it('dependency injection should output the event that was provided to it', () => {
      expect(dependencyInjection.getEvent()).to.eql(getEvent);
    });

    it('dependency injection should output the event that was provided to it', () => {
      expect(dependencyInjection.getContext()).to.eql(getContext);
    });
  });

  describe('should inject the request service into the function', () => {
    LambdaWrapper(configuration, (di, request) => {
      dependencyInjection = di;
      requestService = request;
    })(getEvent, getContext);

    it('request service variables should be an instance of the dependency injection class', () => {
      expect(requestService instanceof RequestService).to.be.true;
    });

    it('request service should contain variables that were sent to it via the event', () => {
      expect(requestService.get('test'), null, REQUEST_TYPES.GET).to.eql(getEvent.queryStringParameters.test);
    });
  });

  describe('should catch exceptions and generate appropriate responses', () => {
    it('Logs the error', () => {
      let loggerStub;

      const lambda = LambdaWrapper(configuration, (di) => {
        loggerStub = sinon.stub(di.dependencies[DEFINITIONS.LOGGER], 'error');
        throw new Error('Some error');
      });

      lambda(getEvent, getContext);

      expect(loggerStub.called).to.be.true;
    });

    it('Returns 500 exception with a common error', () => {
      const lambda = LambdaWrapper(configuration, (di) => {
        sinon.stub(di.dependencies[DEFINITIONS.LOGGER], 'error');
        throw new Error('Some error');
      });

      const response = lambda(getEvent, getContext);
      const body = JSON.parse(response.body);

      expect(response.statusCode).to.be.equal(500);
      expect(body.message).to.be.equal('unknown error');
    });

    it('Returns a response generated by LambdaTermination', () => {
      const lambda = LambdaWrapper(configuration, (di) => {
        sinon.stub(di.dependencies[DEFINITIONS.LOGGER], 'error');
        throw new LambdaTermination('internal', 403, 'external', 'some message');
      });

      const response = lambda(getEvent, getContext);
      const body = JSON.parse(response.body);

      expect(response.statusCode).to.be.equal(403);
      expect(body.data).to.be.equal('external');
      expect(body.message).to.be.equal('some message');
    });

    it('Catches async errors', () => {
      const lambda = LambdaWrapper(configuration, (di) => {
        return new Promise(() => {
          sinon.stub(di.dependencies[DEFINITIONS.LOGGER], 'error');
          throw new LambdaTermination('internal', 403, 'external');
        });
      });

      return lambda(getEvent, getContext).then((response) => {
        const body = JSON.parse(response.body);

        expect(response.statusCode).to.be.equal(403);
        expect(body.message).to.be.equal('unknown error');
        expect(body.data).to.be.equal('external');
      });
    });
  });
});
