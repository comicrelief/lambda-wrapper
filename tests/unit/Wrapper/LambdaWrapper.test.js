import sinon from 'sinon';

import { DEFINITIONS } from '../../../src/Config/Dependencies';
import RequestService, { REQUEST_TYPES } from '../../../src/Service/Request.service';
import DependencyInjection from '../../../src/DependencyInjection/DependencyInjection.class';
import LambdaWrapper from '../../../src/Wrapper/LambdaWrapper';
import LambdaTermination from '../../../src/Wrapper/LambdaTermination';

const getEvent = require('../../mocks/aws/event.json');
const getContext = require('../../mocks/aws/context.json');

describe('Wrapper/LambdaWrapper', () => {
  let dependencyInjection = {};
  let requestService = {};

  const configuration = {
    DEFINITIONS: {},
    DEPENDENCIES: {},
  };

  describe('should inject dependency injection into the function', () => {
    LambdaWrapper(configuration, (di, request) => {
      dependencyInjection = di;
      requestService = request;
    })(getEvent, getContext);

    it('dependency injection variables should be an instance of the dependency injection class', () => {
      expect(dependencyInjection instanceof DependencyInjection).toEqual(true);
    });

    it('dependency injection should output the event that was provided to it', () => {
      expect(dependencyInjection.getEvent()).toEqual(getEvent);
    });

    it('dependency injection should output the event that was provided to it', () => {
      expect(dependencyInjection.getContext()).toEqual(getContext);
    });
  });

  describe('should inject the request service into the function', () => {
    LambdaWrapper(configuration, (di, request) => {
      dependencyInjection = di;
      requestService = request;
    })(getEvent, getContext);

    it('request service variables should be an instance of the dependency injection class', () => {
      expect(requestService instanceof RequestService).toEqual(true);
    });

    it('request service should contain variables that were sent to it via the event', () => {
      expect(requestService.get('test', null, REQUEST_TYPES.GET)).toEqual(getEvent.queryStringParameters.test);
    });
  });

  describe('should catch exceptions and generate appropriate responses', () => {
    it('Logs the error', () => {
      let loggerStub;

      const lambda = LambdaWrapper(configuration, (di) => {
        loggerStub = sinon.stub(di.dependencies[DEFINITIONS.LOGGER], 'error');
        throw new Error('Some error');
      });

      lambda(getEvent, getContext);

      expect(loggerStub.called).toEqual(true);
    });

    it('Returns 500 exception with a common error', () => {
      const lambda = LambdaWrapper(configuration, (di) => {
        sinon.stub(di.dependencies[DEFINITIONS.LOGGER], 'error');
        throw new Error('Some error');
      });

      const response = lambda(getEvent, getContext);
      const body = JSON.parse(response.body);

      expect(response.statusCode).toEqual(500);
      expect(body.message).toEqual('unknown error');
    });

    it('Returns a response generated by LambdaTermination', () => {
      const lambda = LambdaWrapper(configuration, (di) => {
        sinon.stub(di.dependencies[DEFINITIONS.LOGGER], 'error');
        throw new LambdaTermination('internal', 403, 'external', 'some message');
      });

      const response = lambda(getEvent, getContext);
      const body = JSON.parse(response.body);

      expect(response.statusCode).toEqual(403);
      expect(body.data).toEqual('external');
      expect(body.message).toEqual('some message');
    });

    it('Catches async errors', () => {
      const lambda = LambdaWrapper(configuration, (di) => {
        return new Promise(() => {
          sinon.stub(di.dependencies[DEFINITIONS.LOGGER], 'error');
          throw new LambdaTermination('internal', 403, 'external');
        });
      });

      return lambda(getEvent, getContext).then((response) => {
        const body = JSON.parse(response.body);

        expect(response.statusCode).toEqual(403);
        expect(body.message).toEqual('unknown error');
        expect(body.data).toEqual('external');
      });
    });
  });
});
